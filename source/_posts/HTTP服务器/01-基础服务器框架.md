---
title: 01_基础服务器框架
date: 2025-09-21 01:16:22
tags:
categories: HTTP服务器
---
# 基础服务器框架
## 1 创建TCP服务器监听端口
```cpp
// HttpServer.cpp
void HttpServer::Impl::start() {
    server_fd_ = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd_ < 0) {
        perror("socket creation failed");
        return;
    }

    int opt = 1;
    if (setsockopt(server_fd_, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt))) {
        perror("setsockopt failed");
        return;
    }

    sockaddr_in address{};
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(port_);

    if (bind(server_fd_, (sockaddr *)&address, sizeof(address)) < 0) {
        perror("bind failed");
        return;
    }

    if (listen(server_fd_, 10) < 0) {
        perror("listen failed");
        return;
    }
    SPDLOG_INFO("HTTP server running on port {}", port_);
    return;
}
```
1. 创建一个socket，表明要进行互联网的TCP-IPv4通信
2. SO_REUSEADDR，服务器重启时可以立即复用当前端口，避免WAIT_TIME状态导致服务器起不来
3. 设置地址，使用ipv4，绑定所有网卡
4. bind(): 将socket与具体地址/端口关联
5. listen(): socket开始接受连接请求，创建一个长度为10的等待队列

## 2 实现请求接收循环
```cpp
// HttpServer.cpp
void HttpServer::Impl::run() {
    while (true) {

        sockaddr_in client_addr{};
        socklen_t client_len = sizeof(client_addr);
        int client_fd =
            accept(server_fd_, (sockaddr *)&client_addr, &client_len);

        if (client_fd < 0) {
            int err = errno;
            switch (err) {
            case EBADF:
                std::cerr << "accept: server_fd_ is not a valid file descriptor"
                          << std::endl;
                break;
            case ENOTSOCK:
                std::cerr << "accept: server_fd_ is not a socket" << std::endl;
                break;
            case EOPNOTSUPP:
                std::cerr << "accept: socket is not of type SOCK_STREAM"
                          << std::endl;
                break;
            case EINVAL:
                std::cerr << "accept: socket is not listening for connections"
                          << std::endl;
                break;
            default:
                perror("accept failed");
            }
            if (err == EBADF || err == ENOTSOCK) {
                exit(EXIT_FAILURE);
            }
            continue;
        }

        std::thread([this, client_fd] {
            handle_client(client_fd);
            close(client_fd);
        }).detach();
    }
}
```
1. 循环阻塞式接受客户端连接
   - 阻塞式：没有连接请求时cpu阻塞
   - 非阻塞式：没有连接时直接返回

2. 将客户端处理程序放入线程并分离，防止阻塞主线程
   - 风险：
   - 连接数过多时内存耗尽
   - 避免数据竞争（当前不需要）

## 3 解析HTTP请求行和头部
```cpp
// HttpServer.cpp
void HttpServer::Impl::handle_client(int client_fd) {

    try {
        char buffer[4096] = {0};
        ssize_t bytes_read = recv(client_fd, buffer, sizeof(buffer) - 1, 0);
        if (bytes_read <= 0) {
            perror("recv failed");
            return;
        }

        Request request = parse_request(client_fd, buffer);
        Response response(client_fd);
        request_handler_(request, response);

    } catch (const std::exception& e) {
        Request error_req(client_fd);
        Response error_res(client_fd);
        error_handler_(error_req, error_res, e);
    }
}
```
1. recv()阻塞等待客户端数据
   - TODO：超时控制，避免资源占用
2. parse_request()解析请求行和头
3. request_handler_()处理请求
4. error_handler_()处理异常

```cpp
// HttpServer.cpp
Request HttpServer::Impl::parse_request(int client_fd,
                                        const std::string &request) {

    std::istringstream stream(request);
    Request req(client_fd);

    stream >> req.method >> req.path >> req.version;

    std::transform(req.method.begin(), req.method.end(), req.method.begin(),
                   ::toupper);

    stream.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

    std::string header_line;
    while (std::getline(stream, header_line) && header_line != "\r") {
        if (header_line.back() == '\r')
            header_line.pop_back();

        auto colon_pos = header_line.find(':');
        if (colon_pos != std::string::npos) {
            std::string key = header_line.substr(0, colon_pos);
            std::string value = header_line.substr(colon_pos + 1);

            key.erase(0, key.find_first_not_of(" "));
            key.erase(key.find_last_not_of(" ") + 1);
            value.erase(0, value.find_first_not_of(" "));
            value.erase(value.find_last_not_of(" ") + 1);

            req.headers[key] = value;
        }
    }

    // 解析请求体（如果有）
    if (req.headers.find("Content-Length") != req.headers.end()) {
        size_t content_length = std::stoul(req.headers["Content-Length"]);
        req.body.resize(content_length);
        stream.read(&req.body[0], content_length);
    }

    return req;
}
```
1. 请求字符串转换为流
2. 解析方法、路径、协议版本
3. 逐行处理请求头
4. 获取请求体

## 4 返回简单的响应
```cpp
//Response.cpp
void Response::send_headers() {

    std::ostringstream headers;
    headers << "HTTP/1.1 " << status_code_ << " ";
    switch (status_code_) {
    case 200:
        headers << "OK";
        break;
    case 404:
        headers << "Not Found";
        break;
    case 500:
        headers << "Internal Server Error";
        break;
    default:
        headers << "Unknown";
        break;
    }
    headers << "\r\n";

    for (const auto &[key, value] : headers_) {
        headers << key << ": " << value << "\r\n";
    }

    headers << "\r\n"; // 空行分隔头部和正文

    std::string headers_str = headers.str();
    ::send(client_fd_, headers_str.c_str(), headers_str.size(), 0);
}
```
1. 创建headers流
2. 添加协议、状态码、状态文本
3. 添加头和正文间的空行
```cpp
//Response.cpp
void Response::send_file(const std::string &file_path) {

    std::ifstream file(file_path, std::ios::binary);

    // 读取文件内容
    std::ostringstream ss;
    ss << file.rdbuf();
    std::string content = ss.str();

    // 发送响应
    header("Content-Length", std::to_string(content.size()));
    send_headers();
    ::send(client_fd_, content.c_str(), content.size(), 0);

    // 关闭连接
    close(client_fd_);
}
```
1. 将文件内容转换为流
2. 发送头后将流转换为字符串发送
3. 请求关闭连接